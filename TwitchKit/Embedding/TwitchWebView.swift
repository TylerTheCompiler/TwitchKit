//
//  TwitchWebView.swift
//  TwitchKit
//
//  Created by Tyler Prevost on 11/30/20.
//

import WebKit

/// A type that can respond to web view UI events generated by a `TwitchWebView`.
public protocol TwitchWebViewUIDelegate: AnyObject {
    
    /// Informs the UI delegate that Twitch has requested to show a chat conformation dialog in order to
    /// allow the user to chat in an embedded chat view.
    ///
    /// If you implement this method, you must either:
    ///   * Present the suggested chat confirmation dialog by calling `show(from:animated:completion:)` (iOS) or
    ///     `show(in:completion:)` (macOS) on `chatConfirmationDialog`, or
    ///   * Create and presnet your own UI using the properties of `chatConfirmationDialog`. If you choose this
    ///     option, you must make sure to call `chatConfirmationDialog`'s `completionHandler` closure and pass in
    ///     either true (to accept the dialog) or false (to cancel the dialog) to allow the web view to continue
    ///     its internal JavaScript operations.
    ///
    /// - Parameters:
    ///   - twitchWebView: The Twitch web view that received the chat confirmation dialog.
    ///   - chatConfirmationDialog: The suggested chat confirmation dialog that contains the pieces of information
    ///                             to display to the user and the completion handler to call to accept or cancel
    ///                             the dialog.
    func twitchWebView(_ twitchWebView: TwitchWebView,
                       didReceive chatConfirmationDialog: TwitchWebView.ChatConfirmationDialog)
}

/// The base class for all embedded Twitch views. Do not instantiate views of this type directly. Instead,
/// instantiate one of the following subclasses: `TwitchPlayerView`, `TwitchChatView`, or `TwitchClipView`.
open class TwitchWebView: PlatformIndependentView {
    
    /// Represents the UI that appears when attempting to chat in an embedded Twitch chat web view.
    ///
    /// You don't create instances of this class yourself. An instance of this class is returned to the `uiDelegate`
    /// of a `TwitchWebView` in a call to `twitchWebView(_:didReceive:)`.
    open class ChatConfirmationDialog {
        
        /// The title to be shown in the dialog.
        public let title: String
        
        /// The message to be shown in the dialog.
        public let message: String
        
        /// A closure that is called after the user selects a choice from the dialog.
        ///
        /// The `okPressed` boolean represents whether the user pressed the "Accept"/"OK" button (true) or
        /// "Cancel" button (false). Passing in false means the user will not be able to chat in the
        /// corresponding chat view until the web view is refreshed/reloaded.
        ///
        /// If you do not show this dialog yourself using `show(from:animated:completion)` (iOS) or
        /// `show(in:completion:)` (macOS), you should manually call this completion handler yourself and
        /// pass in either true (to allow the user to chat) or false (to disallow the user to chat).
        public let completionHandler: (_ okPressed: Bool) -> Void
        
        /// Creates a new `ChatConfirmationDialog`.
        ///
        /// - Parameters:
        ///   - title: The title to be shown in the dialog
        ///   - message: The message to show in the dialog.
        ///   - completionHandler: The closure that will be called after the user selects a choice from the dialog.
        ///   - okPressed: Whether the user pressed the "Accept"/"OK" button (true) or the "Cancel" button (false).
        public init(title: String,
                    message: String,
                    completionHandler: @escaping (_ okPressed: Bool) -> Void) {
            self.title = title
            self.message = message
            self.completionHandler = completionHandler
        }
        
        #if os(macOS)
        
        /// Shows the dialog as an `NSAlert` in the specified window.
        ///
        /// - Parameters:
        ///   - window: The window in which to show the dialog.
        ///   - completion: A closure called after the user has selected a choice from the dialog. This is called
        ///                 synchronously _after_ `completionHandler` is called. Default: nil.
        open func show(in window: NSWindow, completion: (() -> Void)? = nil) {
            let completionHandler = self.completionHandler
            
            let nsAlert = alertType.init()
            nsAlert.alertStyle = .informational
            nsAlert.messageText = title
            nsAlert.informativeText = message
            nsAlert.addButton(withTitle: "OK")
            nsAlert.addButton(withTitle: "Cancel")
            nsAlert.beginSheetModal(for: window) { response in
                switch response {
                case .alertFirstButtonReturn:
                    completionHandler(true)
                    
                case .alertSecondButtonReturn:
                    fallthrough // swiftlint:disable:this no_fallthrough_only
                    
                default:
                    completionHandler(false)
                }
                
                completion?()
            }
        }
        
        // For unit testing
        internal var alertType: NSAlert.Type = NSAlert.self
        #else
        
        /// Shows the dialog as a `UIAlertController` from the specified view controller.
        ///
        /// - Parameters:
        ///   - viewController: The view controller from which to show the dialog.
        ///   - animated: Whether the dialog presentation should be animated or not. Default: true.
        ///   - completion: A closure called after the presentation animation completes. Default: nil.
        open func show(from viewController: UIViewController,
                       animated: Bool = true,
                       completion: (() -> Void)? = nil) {
            let completionHandler = self.completionHandler
            
            let alertController = UIAlertController(title: title, message: message, preferredStyle: .alert)
            alertController.addAction(alertActionType.makeAction(withTitle: "OK", style: .default) { _ in
                completionHandler(true)
            })
            
            alertController.addAction(alertActionType.makeAction(withTitle: "Cancel", style: .cancel) { _ in
                completionHandler(false)
            })
            
            viewController.present(alertController, animated: animated, completion: completion)
        }
        
        // For unit testing
        internal var alertActionType: UIAlertAction.Type = UIAlertAction.self
        #endif
    }
    
    /// Represents the size of one dimension of a Twitch web view in either absolute or relative terms.
    public enum Dimension {
        
        /// Specifies the dimension in absolute points.
        case absolute(Int)
        
        /// Specifies the dimension in relative terms, from 0 to 100 percent of the width or height of the full
        /// dimension. The integer parameter must be greater than zero and less than or equal to 100.
        case percentage(Int)
        
        internal func stringValue(includeQuotesForPercentages: Bool) -> String {
            switch self {
            case .absolute(let points):
                return points.description
                
            case .percentage(let percentage):
                let value = "\(percentage)%"
                if includeQuotesForPercentages {
                    return "\"\(value)\""
                } else {
                    return value
                }
            }
        }
    }
    
    /// The theme of the Twitch webview, either dark or light.
    public enum Theme: String {
        
        /// The dark Twitch theme.
        case dark
        
        /// The light Twitch theme.
        case light
    }
    
    /// The object that is notified of web view UI events generated by the Twitch web view.
    public weak var uiDelegate: TwitchWebViewUIDelegate?
    
    internal func commonInit() {
        #if os(macOS)
        layer?.backgroundColor = .black
        closeButton.target = self
        closeButton.action = #selector(closeTopChildWebView(_:))
        #else
        backgroundColor = .black
        closeButton.addTarget(self, action: #selector(closeTopChildWebView), for: .touchUpInside)
        #endif
        
        addSubview(closeButton)
        
        closeButton.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            closeButton.topAnchor.constraint(equalTo: topAnchor, constant: 10),
            trailingAnchor.constraint(equalTo: closeButton.trailingAnchor, constant: 10),
            closeButton.widthAnchor.constraint(equalToConstant: 30),
            closeButton.heightAnchor.constraint(equalToConstant: 30)
        ])
        
        closeButton.isHidden = true
    }
    
    @objc internal func closeTopChildWebView(_ sender: Any) {
        guard let topChildWebView = childWebViews.last else { return }
        close(webView: topChildWebView)
    }
    
    private func close(webView: WKWebView) {
        guard let indexOfWebView = childWebViews.firstIndex(of: webView) else { return }
        childWebViews[indexOfWebView...].forEach { $0.removeFromSuperview() }
        childWebViews = childWebViews.dropLast(childWebViews.count - indexOfWebView)
        
        if childWebViews.isEmpty {
            closeButton.isHidden = true
        }
    }
    
    internal func recreateWebView(baseURL: URL?) {
        childWebViews.forEach { $0.removeFromSuperview() }
        closeButton.isHidden = true
        self.webView?.removeFromSuperview()
        
        guard // let webViewConfiguration = webViewConfiguration,
              let htmlString = htmlStringForWebView else {
            return
        }
        
        let webView = Self.webViewType.init(frame: .zero, configuration: webViewConfiguration)
        webView.translatesAutoresizingMaskIntoConstraints = false
        webView.allowsBackForwardNavigationGestures = false
        webView.allowsLinkPreview = false
        webView.uiDelegate = self
        
        #if os(macOS)
        let key = "draws" + "Background"
        webView.setValue(false, forKey: key)
        webView.allowsMagnification = false
        addSubview(webView, positioned: .below, relativeTo: closeButton)
        #else
        webView.isOpaque = false
        webView.backgroundColor = .clear
        webView.scrollView.backgroundColor = .clear
        addSubview(webView)
        sendSubviewToBack(webView)
        #endif
        
        NSLayoutConstraint.activate([
            webView.topAnchor.constraint(equalTo: topAnchor),
            webView.leadingAnchor.constraint(equalTo: leadingAnchor),
            bottomAnchor.constraint(equalTo: webView.bottomAnchor),
            trailingAnchor.constraint(equalTo: webView.trailingAnchor)
        ])
        
        didRecreate(webView: webView)
        self.webView = webView
        
        webView.loadHTMLString(htmlString, baseURL: baseURL ?? URL(string: "https://twitch.tv"))
    }
    
    internal var webViewConfiguration: WKWebViewConfiguration { .init() }
    internal var htmlStringForWebView: String? { nil }
    
    internal func didRecreate(webView: WKWebView) {}
    
    internal var webView: WKWebView?
    internal var childWebViews = [WKWebView]()
    
    #if os(macOS)
    internal let closeButton: NSButton = {
        let image: NSImage?
        if #available(OSX 11.0, *) {
            image = NSImage(systemSymbolName: "xmark.circle.fill", accessibilityDescription: "Close")
        } else {
            image = nil
        }
        
        let button: NSButton
        if let image = image {
            button = NSButton(title: "", image: image, target: nil, action: nil)
        } else {
            button = NSButton(title: "Close", target: nil, action: nil)
        }
        
        return button
    }()
    #else
    internal let closeButton = UIButton(type: .close)
    #endif
    
    // For unit testing
    internal static var webViewType: WKWebView.Type = WKWebView.self
}

extension TwitchWebView: WKUIDelegate {
    public func webView(_ webView: WKWebView,
                        runJavaScriptConfirmPanelWithMessage message: String,
                        initiatedByFrame frame: WKFrameInfo,
                        completionHandler: @escaping (Bool) -> Void) {
        guard let uiDelegate = uiDelegate,
              ["www.twitch.tv", "embed.twitch.tv"].contains(frame.securityOrigin.host),
              message.contains("You are attempting to send"),
              message.contains("""
                               chat via an embedded version of Twitch Chat. \
                               Are you sure you want to do this? \
                               This setting will persist until you refresh the page
                               """) else {
            completionHandler(false)
            return
        }
        
        let chatConfirmationDialog = ChatConfirmationDialog(title: "Twitch Chat",
                                                            message: message,
                                                            completionHandler: completionHandler)
        uiDelegate.twitchWebView(self, didReceive: chatConfirmationDialog)
    }
    
    public func webView(_ webView: WKWebView,
                        createWebViewWith configuration: WKWebViewConfiguration,
                        for navigationAction: WKNavigationAction,
                        windowFeatures: WKWindowFeatures) -> WKWebView? {
        let newWebView = WKWebView(frame: bounds, configuration: configuration)
        #if os(macOS)
        newWebView.autoresizingMask = [.width, .height]
        #else
        newWebView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        #endif
        newWebView.navigationDelegate = self
        newWebView.uiDelegate = self
        childWebViews.append(newWebView)
        
        #if os(macOS)
        addSubview(newWebView, positioned: .below, relativeTo: closeButton)
        #else
        addSubview(newWebView)
        bringSubviewToFront(closeButton)
        #endif
        
        closeButton.isHidden = false
        
        return newWebView
    }
}

extension TwitchWebView: WKNavigationDelegate {
    public func webViewDidClose(_ webView: WKWebView) {
        close(webView: webView)
    }
}
